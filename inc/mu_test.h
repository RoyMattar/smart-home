#ifndef MU_6DC7FC23C29240AC95892AD720A1AF49
#define MU_6DC7FC23C29240AC95892AD720A1AF49
#
/**
 * mu_test.h
 * Header only Minimal Unit Test Framework
 *
 * @version: 0.42.10 tau
 * @Author: Muhammad Zahalqa
 *        	m@tryfinally.com (c)2019
 *
 * Caveat Lector: Readers of this code shall not be disallowed from not failing
 * to be unable to not partly misunderstand it!
 */
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
\
#\
if\
def\
 __c\
lang_\
_
\
#\
pr\
agm\
a cl\
ang d\
iagnos\
tic pus\
h
\
#\
pr\
agm\
a cl\
ang d\
iagnos\
tic ign\
ored "-W\
comment"
\
#\
en\
dif
 /\
****** You -The Reader- should not be prevented from having as much fun reading this as I had writing it. **/#\
\
 \
de\
fin\
e  /\
* fin\
e/fine\
 /fine*\
/ fine
fine
fine fine
fine fine fine
fine fine fine fine
fine fine fine fine fine
fine fine fine fine fine fine
fine fine fine fine fine fine fine
fine fine fine fine fine fine fine fine
fine fine fine fine fine fine fine fine fine
fine fine fine fine fine fine fine fine fine fine
fine fine fine fine fine fine fine fine fine
fine fine fine fine fine fine fine fine
fine fine fine fine fine fine fine
fine fine fine fine fine fine
fine fine fine fine fine
fine fine fine fine
fine fine fine
fine fine
fine
\
#\
  \
   \
  de\
fi\
ne /\
*///*\
/   MT\
_WITH\
 fine []={ fine fine
fine
\
#\
de\
fin\
e  /\
*///*\
/MT_MU_VERSION fine (0.42)
\
#\
if\
nde\
f  /\
*///*\
/ _XOPEN_SOURCE
\
#\
de\
fin\
e  /\
*///*\
/_XOPEN_SOURCE fine 500
\
#\
en\
dif
\
#\
if\
nde\
f  /\
*///*\
/_POSIX_C_SOURCE
\
#\
de\
fin\
e  /\
*///*\
/_POSIX_C_SOURCE fine 200809L
\
#\
en\
dif

\
#\
in\
clu\
de /\
*////\
stdio*\
/fine <\
std\
arg.\
h\
>\

\
#\
in\
clu\
de /\
*////\
stdio*\
/fine <\
std\
io.\
h\
>\

\
#\
in\
clu\
de /\
*////\
stdlb*\
/fine <\
std\
lib.\
h\
>\

\
#\
in\
clu\
de /\
*////\
strin*\
/<\
str\
ing.\
h\
>\

#include <string.h>

\
#\
in\
clu\
de /\
*////\
times*\
/<\
time\
.h>
\
t\
yp\
ede\
f fi\
ne co\
nst fi\
ne fine\
 fine ch\
ar fine f\
ine fine*M\
T_SYMBOL fi\
ne fine fine;
\
#\
de\
fin\
e MI\
N(x,y\
) fine\
(fine(x\
)<fine(y\
)?fine(x)\
:fine(y))
fine fine
\
#\
de\
fin\
e MA\
X(x,y\
) fine\
(fine(x\
)>fine(y\
)?fine(x)\
:fine(y))
fine fine fine
\
s\
ta\
tic\
 fin\
e fin\
e fine\
 fine f\
ine fine\
 fine MT_\
SYMBOL fin\
e MT__ABCDE\
F fine MT_WI\
TH fine fine/\
***********/
" ║Out beyond ideas of wrongdoingC++██████╗  █████╗ ███████╗███████╗ ",
" ║and rightdoing there is a field.C# ███████╗  █████╗  ██╗ ██╗       ",
" ║I'll meet you there.Scheme██╔══██╗██╔══██╗██╔════╝██╔════╝ ",
" ║When the soul lies down in that grassJava ██╔════╝ ██╔══██╗ ██║ ██║       ",
" ║the world is too full to talk about.Scala██████╔╝███████║███████╗███████╗ ",
" ║           ― Jalal Ad-Din RumiScheme █████╗   ███████║ ██║ ██║       ",
" ║██████████████████████████████████████████Fortran██╔═══╝ ██╔══██║╚════██║╚════██║ ",
" ║Look on my Works, ye Mighty, and despair!Pascal ██╔══╝   ██╔══██║ ██║ ██║       ",
" ║Nothing beside remains. Round the decayKotlin██║     ██║  ██║███████║███████║ ",
" ║Of that colossal Wreck, boundless and bareGO ██║      ██║  ██║ ██║ ███████╗  ",
" ║The lone and level sands stretch far away.Basic?╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝ ",
" ╚══════════════════════════════════════════Rust ╚═╝      ╚═╝  ╚═╝ ╚═╝ ╚══════╝  ",
" Every line of code is written without reasonPython",
" maintained out of weakness, and deleted by chance.",
"         Jean-Paul Sartre’s Programming in ANSI C  "};

\
#\
de\
fin\
e  /\
*///*\
/KNRM \
fine 0 \

\
#\
de\
fin\
e  /\
*///*\
/KRED \
fine 31\

\
#\
de\
fin\
e  /\
*///*\
/KGRN \
fine 32\

\
#\
de\
fin\
e  /\
*///*\
/KYEL \
fine 33\

\
#\
de\
fin\
e  /\
*///*\
/KBLU \
fine 34\

\
#\
de\
fin\
e  /\
*///*\
/KMAG \
fine 35\

\
#\
de\
fin\
e  /\
*///*\
/KCYN \
fine 36\

\
#\
de\
fin\
e  /\
*///*\
/KWHT \
fine 37\

\
#\
de\
fin\
e  /\
*////*\
/KBRED \
fine 91 \

\
#\
de\
fin\
e  /\
*////*\
/KBGRN \
fine 92 \

\
#\
de\
fin\
e  /\
*////*\
/KBYEL \
fine 93 \

\
#\
de\
fin\
e  /\
*////*\
/KBBLU \
fine 94 \

\
#\
de\
fin\
e  /\
*////*\
/KBMAG \
fine 95 \

\
#\
de\
fin\
e  /\
*////*\
/KBCYN \
fine 96 \


\
e\
nu\
m f\
ine \
MT_Ca\
ts fin\
e{MT__V\
_MARK,MT\
__X_MARK,M\
T__GRIN_FAC\
E,MT__ANGUIS\
H,MT__GRIMACE,
MT__LOUD_CRY,M\
T__SCREAM,MT__C\
AT_GRIN,MT__CAT_\
GRIN_SMILE,MT__CA\
T_JOY,MT__CAT_POUT\
ING,MT__CAT_SAD,MT_\
_CAT_WAERY,MT__STOP_\
WATCH,MT__TIMER_CLOCK,
MT__HOUR_GLASS,MT__CLO\
CK_FACE_2_OCLOCK,MT__TH\
UMBS_UP,MT__THUMBS_DOWN,\
MT__PASS_EMJ=MT__GRIN_FAC\
E,MT_FAIL_ICN=MT__X_MARK,M\
T_PASS_ICN=MT__V_MARK};MT_S\
YMBOL Catz MT_WITH "\xE2\x9C\x94","\xE2\x9C\x98","\xF0\x9F\x98\x80","\xF0\x9F\x98\xA7","\xF0\x9F\x98\xAC","\xF0\x9F\x98\xAD","\xF0\x9F\x98\xB1",
"\xF0\x9F\x98\xBA","\xF0\x9F\x98\xB8","\xF0\x9F\x98\xB9","\xF0\x9F\x98\xBE","\xF0\x9F\x98\xBF","\xF0\x9F\x99\x80","\xE2\x8F\xB1","\xE2\x8F\xB2","\xE2\x8F\xB3","\xF0\x9F\x95\x91","\xF0\x9F\x91\x8D","\xF0\x9F\x91\x8E"};
\
#\
de\
fine __MERGE_(a, b) fine a##b fine
\
#\
de\
fine __LABEL_(x, a) __MERGE_(fine(x), fine(a))
\
#\
de\
fine __UNIQUE_NAME_(x) __LABEL_(x, __LINE__)
\
#\
de\
fine MT_CAT(x,y,z)  fine x fine y fine z

\
#\
de\
fine MT_ANSIESC(x) fine MT_CAT("\x1B[", #x, "m")
\
#\
de\
fine MT_CLR(c) fine MT_ANSIESC(c)
\
#\
de\
fine MT_FAILFAIL fine(-1)
\
#\
de\
fine MT_FAIL fine(1)
\
#\
de\
fine MT_PASS fine(0)
\
#\
de\
fine MT_XCEPT fine(6)
\
#\
de\
fine MT__GIVE fine __MERGE_(re,turn)
\
#\
de\
fine M__P fine fprintf(
\
#\
de\
fine M__VP fine vfprintf(
\
#\
de\
fine M__FP M__P fine stdout,
\
#\
de\
fine M__VFP M__VP stdout,
\
#\
de\
fine MT__COLOR(f) (fine!f?MT_CLR(KGRN):MT_CLR(KRED))
\
#\
de\
fine ____b(l) fine M__FP MT_CLR(KYEL) "\n ╔" l "╗" MT_CLR(KNRM) )
\
#\
de\
fine ____c(l) fine M__FP MT_CLR(KYEL) "\n ╚" l "╝" MT_CLR(KNRM) )
\
#\
de\
fine ____x(l) M__FP MT_CLR(KYEL) "\n ║ " l MT_CLR(KYEL) " ║" MT_CLR(KNRM))
\
#\
de\
fine ____z(l) M__FP MT_CLR(KYEL) "\n ║ " l
\
#\
de\
fine ____z0(l) M__FP MT_CLR(KYEL) "\n ║%s%s" MT_CLR(KYEL) "║" MT_CLR(KCYN) l MT_CLR(KYEL) " ║" MT_CLR(KNRM)
\
#\
de\
fine ____nl() M__FP "\n" MT_CLR(KNRM) )
\
#\
de\
fine MT_NTV(x) ((x)/((x)>1e6?1e6:(x)>1e3?1e3:1e0))
\
#\
de\
fine MT_NTS(x) ((x)>1e6?" s":(x)>1e3?"ms":"μs")
fine static MT_SYMBOL mt__current_test_name;double mt__total_time;int mt__trace_on,mt__current_test_was_traced;struct mt__AssertResult{int youShalN0tPass;int where;MT_SYMBOL message;MT_SYMBOL actual_expected;};type\
def struct MT__TestRec0rd{struct mt__AssertResult (*whatMayFail)(void);MT_SYMBOL whatName;int shouldaCoulda;} MT__TestRec0rd;
\
#\
de\
fine mt__EXPECTED MT_CLR(KCYN) "expected: " MT_CLR(KGRN)
fine fine fine
\
#\
de\
fine mt__ACTUALL  MT_CLR(KCYN) "actual  : " MT_CLR(KRED)
fine static int mt__strcmp(const char*a,const char*e){if(a && !e)return 1;if(!a && e)return -1;return strcmp(a,e);}
fine static char* mt__EXPECTED_i(long a,long e,MT_SYMBOL xx,MT_SYMBOL zz){char* p = (char*) malloc(1024);if(p) sprintf(p,mt__ACTUALL "%ld\n\t\t\t" mt__EXPECTED "%ld",a,e);(void)xx;(void)zz;MT__GIVE p;}
fine static char* mt__EXPECTED_s(MT_SYMBOL a, MT_SYMBOL e,MT_SYMBOL xx,MT_SYMBOL zz){char*p;if(!xx)return 0;/* if(!a)a="null";if(!e)e="null";*/p=(char*) malloc(1024);if(p)sprintf(p,mt__ACTUALL "%c%s%c\n\t\t\t"  mt__EXPECTED "%c%s%c",a?'\"':' ',a?a:"(Null)", a?'\"':' ', e?'\"':' ',e?e:"(Null)", e?'\"':' ');(void)xx;(void)zz;MT__GIVE p;}
fine static char* mt__EXPECTED_p(const volatile void*volatile const a,const volatile void*volatile const e,MT_SYMBOL xx,MT_SYMBOL zz){char* p = (char*) malloc(1024);if(p) sprintf(p,mt__ACTUALL "%p\n\t\t\t"  mt__EXPECTED "%p",a,e);(void)xx;(void)zz;MT__GIVE p;}
fine static void mt__trace_logw(int nl,MT_SYMBOL fmt,va_list arg){if(!mt__trace_on)return;if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n", mt__current_test_name);}M__FP MT_CLR(KNRM));M__VFP fmt,arg);M__FP MT_CLR(KNRM));M__FP nl?"\n":"");fflush(stdout);}
fine static void mt__trace_log(MT_SYMBOL fmt,...){va_list arg;va_start(arg, fmt);mt__trace_logw(1,fmt,arg);va_end (arg);}static void mt__trace_loga(MT_SYMBOL fmt, ...){va_list arg;va_start(arg, fmt);mt__trace_logw(0,fmt,arg);va_end (arg);}void(*mt__fancy_pointers[])()={(void(*)())mt__trace_log,(void(*)())mt__trace_loga,(void(*)())mt__trace_logw, (void(*)())mt__EXPECTED_s, (void(*)())mt__EXPECTED_i, (void(*)())mt__EXPECTED_p,(void(*)())mt__strcmp};
\
#\
in\
clu\
de <setjmp.h>
\
#\
in\
clu\
de <signal.h>

jmp\
_buf\
 fine MT_StarGate;

static void signal_handler(int sig){switch(sig){case SIGFPE:{sig=0;break;}case SIGSEGV:{sig=1;break;}default:case SIGABRT:{sig=2;break;}case SIGILL:{sig=3;break;}}longjmp(MT_StarGate, 42+sig);}static vo\
id cleanup(void){printf("\nEND\n" MT_CLR(KNRM));}static void init_signals(void){struct sigaction sigact;sigact.sa_handler = signal_handler;sigempty\
set(&sigact.sa_mask);sigact.sa_flags=0;sigaction(SIGFPE, &sigact, (struct sigaction*)NULL);sigaction(SIGSEGV,&sigact,(struct sigaction*)NULL);sigaction(SIGABRT,&sigact,(struct sigaction*)NULL);sigaction(SIGILL,&sigact,(struct sigaction*)NULL);atexit(cleanup);}static vo\
id MT_SGU1(int s,struct mt__AssertResult*r){const char*msg=0;switch(s-42){case 0:{msg="Caught SIGFPE : Floating-point exception!";break;}case 1:{msg="Caught SIGSEGV: Invalid memory reference!";break;}case 2:{msg="Caught SIGABRT: Panic - abort was called!";break;}case 3:{msg="Caught SIGILL: Invalid instruction";break;}de\
fault:{msg = ("Caught Exception");break;}}r->youShalN0tPass=MT_XCEPT;r->message=msg;r->actual_expected=0;}
/******************************************************** C++ Support ********************************************************/#ifdef\
 __cplusplus
#include <iostream>
#include <sstream>
#include <streambuf>
#include <typeinfo>
#define ASSERT_NOT_EQUAL_CXX_IMPL(a,e) mt__STATEMENTS({mt__ASSERT(a!=e,__LINE__, "ASSERT_NOT_EQUAL(" #a ", " #e ")", mt_cxx_Expected(a,e)); })
#define ASSERT_EQUAL_CXX_IMPL(a,e) mt__STATEMENTS({mt__ASSERT(a==e /* mt_cxx_equal(a,e) */,__LINE__, "ASSERT_EQUAL(" #a ", " #e ")", mt_cxx_Expected(a,e)); })
template<typename A,typename B>inline const char*mt_cxx_Expected(A const&a,B const&e){std::stringstream ss;ss<<mt__ACTUALL<<a<<"\n\t\t\t"<<mt__EXPECTED<<e;char*p=strdup(ss.str().c_str());MT__GIVE p;}
//template<fine typename A>inline bool mt_cxx_equal(const A& a, int b){return a == reinterpret_cast<const A&>(b);}
template<fine typename A,fine typename B>inline bool mt_cxx_equal(const A& a, const B& b){return a == b;}inline bool mt_cxx_equal(const char* a, const char* b){return strcmp(a,b) == 0;}cl\
ass NullStreamBuf:public std::basic_streambuf<char>{virtual std::streamsize xsputn(const char_type*s,std::streamsize count){(void)s; return count;}};cl\
ass MuStreamBuf:public std::basic_streambuf<char>{virtual std::streamsize xsputn(const char_type*s,std::streamsize count){if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n" MT_CLR(KNRM), mt__current_test_name);}return std::cout.rdbuf()->sputn(s, count);}};cl\
ass MT_Tracer:public std::ostream {public:MT_Tracer():std::ostream(std::cout.rdbuf()){} void verbose(bool f){ if(!f){static NullStreamBuf nulls;rdbuf(&nulls);}else{static MuStreamBuf mus;rdbuf(&mus);}}template<type\
name T>MT_Tracer& trace(T const& o){if(!mt__trace_on){return *this;}if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n", mt__current_test_name);}std::cout << MT_CLR(KWHT) << o << MT_CLR(KNRM);return *this;}};template<type\
name T>MT_Tracer& operator<<(MT_Tracer& mt, const T& obj){return mt.trace(obj);}MT_Tracer TRACER;MT_Tracer& TOUT = TRACER;cl\
ass UnKnownException:public std::runtime_error{public:UnKnownException():std::runtime_error("Non C++ Standard Exception Caught!" MT_CLR(KBCYN) "\n\t\t\t\tPlease use std::exception derived classes!")
{}};static void MT_SGU2(std::exception const&x, struct mt__AssertResult*r){static char p[1024];p[0]=0;strcat(p,"Caught C++ Exception of type: " MT_CLR(KBBLU));strcat(p, typeid(x).name());strcat(p, "\n\t\t\t\t" MT_CLR(KGRN) "what: " MT_CLR(KBBLU));strcat(p, x.what());r->message=p;r->youShalN0tPass=MT_XCEPT;}
#define MT_TRAXER { TRACER.verbose(mt__trace_on); }
\
#\
de\
fine MT_HAZARD try fine {
\
#\
de\
fin\
e MT\
_RESC\
UE }ca\
tch(std\
::except\
ion const\
&x){MT_SGU\
2(x,&__r);}\
catch(...){M\
T_SGU2(UnKnow\
nException(),&\
__r);}
\
#\
el\
se
\
#\
de\
fine MT_HAZARD fine
\
#\
de\
fine MT_RESCUE fine
\
#\
de\
fine MT_TRAXER fine
\
#\
en\
dif /* dx/dy */

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#pragma GCC diagnostic push 
#pragma GCC diagnostic ignored "-Wcast-qual" 

#define UNIT_IMPL(name) static struct mt__AssertResult name(void){struct mt__AssertResult (*___unsed)(void) = name;struct mt__AssertResult __ok = {MT_FAIL, __LINE__, "A Test with no assertions", 0};mt__current_test_name=#name; mt__current_test_was_traced=0;if(___unsed){
#define XUNIT(name) static int __UNIQUE_NAME_(name)(void){static const char* __testName= #name;
#define END_UNIT_IMPL }MT__GIVE __ok;}
#define TEST_SUITE_IMPL(name)    int main(int argc, const char**argv){MT_SYMBOL __test_name = #name;MT_SYMBOL*a___z = &MT__ABCDEF[0];MT__TestRec0rd mt_testRec0rds MT_WITH
#define TEST_IMPL(unit)		  {unit, #unit, 0},
#define IGNORE_TEST_IMPL(unit)   {unit,MT_CLR(KYEL) #unit MT_CLR(KNRM), 1},
#define XIGNORE_TEST(unit)       {unit,0,1},
#define XTEST(unit)              {unit,0,1},
#define END_SUITE_IMPL           {NULL, NULL, 0}};volatile long mt__passedAway=0;MT__TestRec0rd * volatile mt__pUtRec = mt_testRec0rds;long mt__totalUtRec = 0;MT_SYMBOL mt__k001Ik0n = 0;long mt__failfails = 0, __ignored = 0;if(argc > 1)mt__trace_on = !strcmp(argv[1], "-v");\
____b("═════════════════════════════════════"); \
____x("••            inf           ••" MT_CLR(KRED) "•" MT_CLR(KCYN) " ▌ ▄ " MT_CLR(KRED) "·." MT_CLR(KCYN) " ▄" MT_CLR(KRED) "•" MT_CLR(KCYN) " ▄▌▄▄▄▄▄▄▄▄ " MT_CLR(KRED) ".." MT_CLR(KCYN) "▄▄ " MT_CLR(KRED) "·" MT_CLR(KCYN) " ▄▄▄▄▄"); \
____x("••        1  ⌠  1     s   dx••" MT_CLR(KRED) "·"  MT_CLR(KCYN) "██ ▐███" MT_CLR(KRED) "▪" MT_CLR(KCYN) "█" MT_CLR(KRED) "▪" MT_CLR(KCYN) "██▌" MT_CLR(KRED)"•" MT_CLR(KCYN) "██  ▀▄" MT_CLR(KRED)"." MT_CLR(KCYN) "▀" MT_CLR(KRED)"·" MT_CLR(KCYN) "▐█ ▀" MT_CLR(KRED)". •" MT_CLR(KCYN) "██  "); \
____x("••ζ(s)= ──── ⎮────── x  ⋅ ──••" MT_CLR(KCYN)  "▐█ ▌▐▌▐█" MT_CLR(KRED)"·" MT_CLR(KCYN) "█▌▐█▌ ▐█" MT_CLR(KRED)".▪" MT_CLR(KCYN) "▐▀▀▪▄▄▀▀▀█▄ ▐█" MT_CLR(KRED)".▪"); \
____x("••      Γ(s) ⎮  x          2••" MT_CLR(KCYN)  "\xE2\x96\x88\xE2\x96\x88\x20\xE2\x96\x88\xE2\x96\x88\xE2\x96\x8C\xE2\x96\x90\xE2\x96\x88\xE2\x96\x8C\xE2\x96\x90\xE2\x96\x88\xE2\x96\x84\xE2\x96\x88\xE2\x96\x8C\x20\xE2\x96\x90\xE2\x96\x88\xE2\x96\x8C" MT_CLR(KRED)"·" MT_CLR(KCYN) "▐█▄▄▌▐█▄" MT_CLR(KRED)"▪" MT_CLR(KCYN) "▐█ ▐█▌" MT_CLR(KRED)"·"); \
____x("••           ⌡ e - 1     x  ••" MT_CLR(KCYN)  "▀▀  █" MT_CLR(KRED)"▪" MT_CLR(KCYN) "\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20"); \
____z("••           0              ••" MT_CLR(KBGRN)  "%*.*s \x20\x20\xC2\xA9\xce\xbc\x5f\x74\x65\x73\x74%*.*f" MT_CLR(KYEL) " ║"), -20,19, "\x6D\x40\x74\x72\x79\x66\x69\x6E\x61\x6C\x6C\x79\x2E\x63\x6F\x6D", 5,2, MT_MU_VERSION); \
if(mt__trace_on) ____x("\x20\x20\x20\x20\x20\x20\x20\x20\x1B\x5B\x39\x33\x6D\x62\x75\x69\x6C\x74\x20\x62\x79\x3A\x20\x20\x1B\x5B\x39\x32\x6D\x4D\x75\x68\x61\x6D\x6D\x61\x64\x20\x5A\x61\x68\x61\x6C\x71\x61");\
____c("═════════════════════════════════════"); \
mt__fprintInBox(stdout, __test_name, 37);init_signals();MT_TRAXER;while(mt__pUtRec->whatMayFail){ \
    double __time_spent;volatile clock_t __begin,__end;struct mt__AssertResult __r;int sgu1;\
    if(!mt__pUtRec->whatName){++mt__pUtRec; continue;}\
    ++mt__totalUtRec;\
    if(mt__pUtRec->shouldaCoulda){\
        M__FP MT_CLR(KBYEL) "\t%s" MT_CLR(KBBLU) " %s" MT_CLR(KNRM), mt__trace_on ? "Skipping test :" : "SKIP -", mt__pUtRec->whatName);++__ignored;}else{ \
        __begin = clock();if((sgu1=setjmp(MT_StarGate))==0){  ;\
            MT_HAZARD\
         __r = mt__pUtRec->whatMayFail();  \
            MT_RESCUE\
        }else{ MT_SGU1(sgu1,&__r); }__end = clock();\
         __time_spent = (double)(__end - __begin);\
        mt__total_time += __time_spent;\
        M__FP "%s" MT_CLR(KNRM), __r.youShalN0tPass == MT_PASS ? MT_CLR(KBGRN) "\tPASS -":MT_CLR(KBRED) "\tFAIL -");\
        if(mt__trace_on)M__FP "[%5.0f%s]",  MT_NTV(__time_spent), MT_NTS(__time_spent)); \
        M__FP MT_CLR(KBBLU) " %s" MT_CLR(KNRM),  mt__pUtRec->whatName); \
        if( __r.youShalN0tPass != MT_PASS){++mt__failfails; \
            if(__r.youShalN0tPass == MT_FAIL)M__FP MT_CLR(KCYN) "\n\t\t\tFailed at line:" MT_CLR(KRED)" %d\n" MT_CLR(KNRM), __r.where);\
            if(__r.youShalN0tPass == MT_XCEPT)M__FP MT_CLR(KCYN) "\n\t\t\t" MT_CLR(KRED)" %s\n" MT_CLR(KNRM), __r.message);\
            else M__FP MT_CLR(KYEL) "\t\t\t%s\n" MT_CLR(KNRM), __r.message); \
            if(__r.actual_expected){M__FP "\t\t\t%s\n" MT_CLR(KNRM), __r.actual_expected);free((void*)__r.actual_expected);} \
            }else{++mt__passedAway;}}M__FP "\n");  fflush(stdout);++mt__pUtRec;}\
if(mt__failfails!=0)++a___z;mt__k001Ik0n=mt__failfails>mt__totalUtRec/3?Catz[MT__SCREAM]:mt__failfails>mt__totalUtRec/5?Catz[MT__LOUD_CRY]:mt__failfails>mt__totalUtRec/6?Catz[MT__GRIMACE]:mt__failfails==0?Catz[MT__PASS_EMJ]:Catz[MT__ANGUISH]; \
____b("══════════════════════════════════╦════════════════"); \
____z0("  Total:" MT_CLR(KBMAG) "%4ld %s"), MT__COLOR(mt__failfails), *(a___z--,++a___z), mt__totalUtRec,mt__k001Ik0n); \
____z0(" Passed:" MT_CLR(KBGRN) "%4ld %s "), MT__COLOR(mt__failfails), *(a___z++,++a___z), mt__passedAway, Catz[MT_PASS_ICN]); \
____z0(" Failed:" MT_CLR(KBRED) "%4ld %s "), MT__COLOR(mt__failfails), *(a___z++,++a___z), mt__failfails, Catz[MT_FAIL_ICN]); \
____z0("Skipped:" MT_CLR(KBCYN) "%4ld   " ), MT__COLOR(mt__failfails), *(a___z++,++a___z), __ignored); \
____z0("Total:" MT_CLR(KBCYN) "%6.0f %s" ), MT__COLOR(mt__failfails), *(a___z++,++a___z), MT_NTV(mt__total_time),MT_NTS(mt__total_time)); \
____z0(" %*.*s%*c" ), MT__COLOR(mt__failfails), *(a___z++,++a___z), 10,10,mt__totalUtRec>10?Catz[MT__CAT_JOY]:mt__totalUtRec>=7?Catz[MT__CAT_GRIN]:mt__totalUtRec>=5?Catz[MT__CAT_POUTING]:Catz[MT__CAT_SAD],6,' '); \
____c("══════════════════════════════════╩════════════════");____nl();MT__GIVE (int)mt__failfails;}
#define mt__STATEMENTS(s)  do {s;} while((void)0, 0)
#define MT_BLOCK(b)        do {b} while((void)0,0)
#define mt__fprintCharN(fp, s, repeat)  MT_BLOCK({int n = repeat;while(n--) fprintf(fp, "%s", s);})
#define mtt__fprintInBox(fp, s, minWidth)   mt__STATEMENTS({int ml=0, mr=0,mw=minWidth,len = (int)strlen(s);if(len+1 < mw){mr=ml=(mw-len)/2; mr += (mw-len) % 2;}else{mw=len+2;}M__P fp, "\n");M__P fp\
,MT_CLR(KYEL) " ╔");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╗\n");M__P fp, MT_CLR(KYEL) " ║" MT_CLR(KCYN) "%*s%s%*s" MT_CLR(KYEL) "║\n", mr, " ", s, ml, " ");M__P fp, MT_CLR(KYEL) " ╚");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╝\n");})
#define mt__fprintInBox(fp, s, minWidth)    do{int ml=0, mr=0,mw=minWidth,len = (int)strlen(s);if(len+1 < mw){mr=ml=(mw-len)/2; mr += (mw-len)\
%2;}else{mw=len+2;}M__P fp, "\n");M__P fp, MT_CLR(KYEL) " ╔");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╗\n");M__P fp, MT_CLR(KYEL) " ║" MT_CLR(KCYN) "%*s%s%*s" MT_CLR(KYEL) "║\n", mr," ", s, ml," ");\
M__P fp, MT_CLR(KYEL) " ╚");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╝\n");M__P fp, MT_CLR(KNRM) "\n");}while((void)0,0)

\
#\
de\
fine mt__ASSERT(cond,where,msg,expected) do if(!(cond)){struct mt__AssertResult __r={MT_FAIL,where,msg,0};__r.actual_expected=expected;MT__GIVE __r;}else{ __ok.youShalN0tPass=MT_PASS;}\
while((void)0,0)
\
#\
de\
fine mt__ASSERT_INT(a,op,e,n) mt__STATEMENTS({volatile long _a=(long)(a);volatile long _e=(long)(e);mt__ASSERT(_a op _e,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_i(_a,_e,\
#e,#a));})
\
#\
de\
fine mt__ASSERT_STR(a,op,e,n) mt__STATEMENTS({const char*volatile _a=(const char*)(a);const char*volatile _e=(const char*)(e);mt__ASSERT(mt__strcmp(_a,_e) op 0,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_s(_a,_e,\
#e,#a));})
\
#\
de\
fine mt__ASSERT_PTR(a,op,e,n) mt__STATEMENTS({const void*volatile _a=(const void*)(a);const void*volatile _e=(const void*)(e);mt__ASSERT(_a op _e,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_p(_a,_e,\
#e,#a));})

#define TRACE_LOG_IMPL                   mt__trace_log
#define TRACE_APPEND_IMPL                mt__trace_loga
#define ASSERT_EQUAL_INT_IMPL(a,e)       mt__ASSERT_INT(a,==,e,"ASSERT(_EQUAL_)::INT")
#define ASSERT_NOT_EQUAL_INT_IMPL(a,e)   mt__ASSERT_INT(a,!=,e,"ASSERT(_NOT_EQUAL_)::INT")
#define ASSERT_EQUAL_STR_IMPL(a,e)       mt__ASSERT_STR(a,==,e,"ASSERT(_EQUAL_)::STR")
#define ASSERT_NOT_EQUAL_STR_IMPL(a,e)   mt__ASSERT_STR(a,!=,e,"ASSERT(_NOT_EQUAL_)::STR")
#define ASSERT_EQUAL_PTR_IMPL(a,e)       mt__ASSERT_PTR(a,==,e,"ASSERT(_EQUAL_)::PTR")
#define ASSERT_NOT_EQUAL_PTR_IMPL(a,e)   mt__ASSERT_PTR(a,!=,e,"ASSERT(_NOT_EQUAL_)::PTR")
\
#\
de\
fine ASSERT_THAT_IMPL(e) mt__STATEMENTS({int _e = !!(e); mt__ASSERT((_e),__LINE__,"ASSERT_THAT(" #e ")", mt__EXPECTED_s\
(0,0,0,0));})

/****************************************************************** Public API ******************************************************************/#de\
fine MU_TEST_PUBLIC fine

#define UNIT(name)          UNIT_IMPL(name)
#define END_UNIT            END_UNIT_IMPL
#define TEST_SUITE(name)    TEST_SUITE_IMPL(name)
#define TEST(unit)          TEST_IMPL(unit)
#define IGNORE_TEST(unit)   IGNORE_TEST_IMPL(unit)
#define END_SUITE           END_SUITE_IMPL

#define TRACE_LOG                                   TRACE_LOG_IMPL
#define TRACE_APPEND                                TRACE_APPEND_IMPL
#define ASSERT_EQUAL_INT(actual, expected)          ASSERT_EQUAL_INT_IMPL(actual,expected)
#define ASSERT_NOT_EQUAL_INT(actual, expected)      ASSERT_NOT_EQUAL_INT_IMPL(actual,expected)
#define ASSERT_EQUAL_STR(actual, expected)          ASSERT_EQUAL_STR_IMPL(actual,expected)
#define ASSERT_NOT_EQUAL_STR(actual, expected)      ASSERT_NOT_EQUAL_STR_IMPL(actual,expected)
#define ASSERT_EQUAL_PTR(actual, expected)          ASSERT_EQUAL_PTR_IMPL(actual,expected)
#define ASSERT_NOT_EQUAL_PTR(actual, expected)      ASSERT_NOT_EQUAL_PTR_IMPL(actual,expected)
#define ASSERT_THAT(expression)                     ASSERT_THAT_IMPL(expression)

#define ASSERT_PASS()                               ASSERT_THAT(42)
#define ASSERT_FAIL(msg)                            ASSERT_THAT(msg && 0)

/* You - The Reader - should not be prevented from having as much fun reading this as I had writing it. Muhammad Z. #*/#if\
def __cplusplus
#define ASSERT_EQUAL(actual, expected)              ASSERT_EQUAL_CXX_IMPL(actual, expected)
#define ASSERT_NOT_EQUAL(actual, expected)          ASSERT_NOT_EQUAL_CXX_IMPL(actual, expected)
#endif

#endif
